//
// Created by 이동한 on 2025. 3. 12..
//
/** 비트마스킹의 요지는 불리언 배열을 단순한 수로 치환하여 계산하는 것이다.
문제
N2개의 동전이 N행 N열을 이루어 탁자 위에 놓여 있다.
그 중 일부는 앞면(H)이 위를 향하도록 놓여 있고, 나머지는
뒷면(T)이 위를 향하도록 놓여 있다.
<그림 1>은 N이 3일 때의 예이다.

이들 N2개의 동전에 대하여 임의의 한 행 또는 한 열에 놓인
N개의 동전을 모두 뒤집는 작업을 수행할 수 있다. 예를 들어
<그림 1>의 상태에서 첫 번째 열에 놓인 동전을 모두 뒤집으면
<그림 2>와 같이 되고, <그림 2>의 상태에서 첫 번째 행에
놓인 동전을 모두 뒤집으면 <그림 3>과 같이 된다.
<그림 2>	<그림 3>
<그림 3>의 상태에서 뒷면이 위를 향하여 놓인 동전의 개수는 두 개이다.
<그림 1>의 상태에서 이와 같이 한 행 또는 한 열에 놓인 N개의 동전을
모두 뒤집는 작업을 계속 수행할 때 뒷면이 위를 향하도록 놓인 동전의
개수를 2개보다 작게 만들 수는 없다.

N2개의 동전들의 초기 상태가 주어질 때, 한 행 또는 한 열에 놓인
N개의 동전을 모두 뒤집는 작업들을 수행하여 뒷면이 위를 향하는 동전
개수를 최소로 하려 한다. 이때의 최소 개수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 20이하의 자연수 N이 주어진다. 둘째 줄부터 N줄에
걸쳐 N개씩 동전들의 초기 상태가 주어진다. 각 줄에는 한 행에
놓인 N개의 동전의 상태가 왼쪽부터 차례대로 주어지는데, 앞면이
위를 향하도록 놓인 경우 H, 뒷면이 위를 향하도록 놓인 경우 T로
표시되며 이들 사이에 공백은 없다.

출력
첫째 줄에 한 행 또는 한 열에 놓인 N개의 동전을 모두 뒤집는
작업들을 수행하여 뒷면이 위를 향하여 놓일 수 있는 동전의 최소 개수를 출력한다.

예제 입력 1
3
HHT
THH
THT
예제 출력 1
2
 * @see https://www.acmicpc.net/problem/1285
 */
#include <bits/stdc++.h>
using namespace std;
const int INF = 987654321;
int n,a[41],ret=INF;
string s;
void go(int idx) {
    // n번째 (끝까지) 도착하였다면 '열' 별로 뒷면과 앞면 중 적은값(뒤집으면 되므로) 합에더하기.
    if (idx == n) {
        int sum=0;
        // 뒷면(T)가 존재하는지 열별로 순회한다.
        for (int i=1; i<= (1 << n-1); i*=2) {
            int cnt=0;
            // for (int j=0; j<n; j++) {
            //     if (a[j] & i) cnt++;
            // }
            // 모든 행의 현재 열 중 뒤집힌 면이 있는지 조회
            for (int j=0; j<n; j++) if (a[j] & i) cnt++;
            // 열뒤집기
            sum += min(cnt, n-cnt); // 뒷면의수 (뒤집으면 같으므로) 더하기
        }
        ret = min(ret,sum);
        return;
    }
    go(idx+1);
    a[idx] = ~a[idx]; // 행 뒤집기.
    go(idx+1);
}
int main() {
    ios_base::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);
    cin >> n;
    for (int i=0; i<n; i++) {
        cin >>s;
        int value = 1;
        for (int j=0; j<n; j++) {
            if (s[j] == 'T') a[i] |=value;
            value *=2;
        }
    }
    go(0);
    cout << ret << "\n";
    return 0;
}
