# Dynamic programming

다이내믹 프로그래밍은 brute force 전략을 취하되 계산한 것은 계산하지 않는(중복 계산 하지 않는) 구조를 가지는 전략이다.
이는 1. 초기화 / 2. 기저 조건 / 3. 메모이제이션 / 4.로직 으로 구성된다.

## 예제 : 사과나무 사과 받기

백설공주은 사과를 매우 좋아한다. 그래서 집에 사과나무를 두 그루 심어두고, 그 나무에서 떨어지는
사과를 받아먹곤 한다. 하지만 백설공주은 키가 작아서 사과를 직접 따먹지는 못하고, 사과가 떨어질
때까지 기다린다. 백설공주은 사과가 떨어지는 순간에만 이를 잡을 수 있으며, 사과가 땅에 떨어지면
깨져서 먹을 수 없게 된다.
매 초마다, 두 개의 나무 중 하나에서 사과가 떨어진다. 백설공주이 사과를 잡으려면 사과가 떨어지는
나무 아래에 서 있어야 하며, 백설공주은 빠르게(1초보다 짧은 시간 안에) 다른 나무로 이동할 수 있다.
그러나 백설공주의 체력은 그리 좋지 않아 많이 움직일 수 없다.
백설공주은 S(1≤S≤100)초 동안 사과를 잡을 수 있다. 백설공주은 최대 M(1≤M≤30)번만 이동할 수 있다. 매
초마다 어느 나무에서 사과가 떨어질지에 대한 정보가 주어졌을 때, 백설공주이 받을 수 있는 사과의 최대
개수를 구하는 프로그램을 작성하시오. 백설공주은 처음에는 1번 사과나무 아래에 위치해 있다.
입력

178

첫째 줄에 두 정수 S와 M이 주어진다. 다음 S개의 줄에는 매 초마다 떨어지는 사과의 나무 번호가 1
또는 2로 주어진다.
출력
첫째 줄에 백설공주이 받을 수 있는 사과의 최대 개수를 출력한다.
예제 입력 1
7 2
2
1
1
2
2
1
1

예제 출력 1
6

## 풀이
```c++
#include <bits/stdc++.h>
using namespace std;

int n,m,dp[101][2][31], b[101];

int go(int idx, int tree, int cnt){
    if (cnt < 0 ) return -1e9; // 2.기저사례 => 움직일 수 있는 횟수 이상으로 움직이면 아주 큰 음수를 반환해 갱신되지 않도록한다.
    if (idx == n) return 0; // 2. 기저사례 -> 시간이 주어진 조건 만큼 경과 하였을때 종료해준다.
    int &ret = dp[idx][tree][cnt];
    
    if (ret != -1) return ret;
    return ret = max(go(idx + 1, tree ^ 1, cnt - 1), go(idx + 1, tree, cnt)) + // 3. 메모이제이션 + 4.로직 -> 현상황으로 부터 움직인 경우, 움직이지 않은 경우중 큰 값으로 갱신하다. 
        (tree == b[idx] - 1); // 지금있는 나무에서 사과가 떨어졌으면 1을 더해준다.

}

int main(){
    memset(dp, -1, sizeof(dp)); // 1. 초기화 단계 : 메모이제이션 배열을 초기화 해준다.
    cin >> n >> m;
    for (int i=0; i<n; i++) cin >> b[i];
    cout << max(go(0,0,m), go(0,1,m)) << "\n";   
    return 0;
}
```

## DP 종류 - TOP down, Bottom up

### TOP down

재귀 함수의 스레드 컨텍스트를 생성하므로 오버헤드가 크다. 하지만 필요한 경우의 수만 계산하는 장점이있다.

### Bottom up

필요하지 않는 모든 경우의 수를 카운트해야하는 단점이 있다. 그러나 압도적으로 적은 컨텍스트 스위칭 때문에 더 효율적이다.


## counting combination

dp를 이용해 경우의 수를 구할때는 이전에 갱신된 모든 자료를 갱신될 자료에 더한다.

### 예제:

큰돌은 숫자와 놀이하는 것을 좋아한다. 그는 정수 하나를 선택한 다음, 그 숫자를 1, 2, 3의 합으로
표현하는 방법을 찾으려고 한다. 예를 들어, 숫자 4를 1, 2, 3의 합으로 나타내는 방법은 총 4가지가
있다. 합을 나타낼 때는 숫자를 1개 이상 사용해야 하며, 합을 이루고 있는 숫자의 순서는 중요하지
않다.
큰돌은 모든 가능한 경우의 수를 알고 싶어한다. 큰돌을 도와 주어진 숫자를 1, 2, 3의 합으로
나타낼 수 있는 방법의 수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이
주어진다. n은 양수이며 10,000보다 작거나 같다.
출력

184

각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타낼 수 있는 방법의 수를 출력한다.
예제 입력 1
3
4
8
15

예제 출력 1
4
10
27

### 풀이: 

```c++
#include <iostream>
using namespace std;

int T, dp[10001],n;

int main(){
    cin >> T;
    for (int i=0; i<T; i++){
        cin >> n;
        memset(dp,0, n+1);
        dp[0] = 1;
        // 이중 for 문 구조에 의해 1 -> 2 -> 3 순으로 누적 되어 갱신됨
        for (int i=1; i<=3; i++){ 
            for (int j=1; j<=n; j++){
                if (j - i >=0) dp[j] += dp[j-i];
            }
            cout << dp[n] << "\n";
        }
    }
    return 0;
}
```